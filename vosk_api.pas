unit vosk_api;
{ This unit is automatically generated by Chet:
  https://github.com/neslib/Chet }

{$MINENUMSIZE 4}

interface

const
  {$IF Defined(WIN32)}
  LIB_VOSK = 'libvosk.dll';
  _PU = '';
  {$ELSEIF Defined(WIN64)}
  LIB_VOSK = 'libvosk.dll';
  _PU = '';
  {$ELSE}
    {$MESSAGE Error 'Unsupported platform'}
  {$IFEND}

type
  PVoskModel = Pointer;
  PPVoskModel = ^PVoskModel;
  PVoskSpkModel = Pointer;
  PPVoskSpkModel = ^PVoskSpkModel;
  PVoskRecognizer = Pointer;
  PPVoskRecognizer = ^PVoskRecognizer;
  PVoskBatchModel = Pointer;
  PPVoskBatchModel = ^PVoskBatchModel;
  PVoskBatchRecognizer = Pointer;
  PPVoskBatchRecognizer = ^PVoskBatchRecognizer;

(** Loads model data from the file and returns the model object
 *
 * @param model_path: the path of the model on the filesystem
 * @returns model object or NULL if problem occured *)
function vosk_model_new(const model_path: PAnsiChar): PVoskModel; cdecl;
  external LIB_VOSK name _PU + 'vosk_model_new';

(** Releases the model memory
 *
 *  The model object is reference-counted so if some recognizer
 *  depends on this model, model might still stay alive. When
 *  last recognizer is released, model will be released too. *)
procedure vosk_model_free(model: PVoskModel); cdecl;
  external LIB_VOSK name _PU + 'vosk_model_free';

(** Check if a word can be recognized by the model
 * @param word: the word
 * @returns the word symbol if @param word exists inside the model
 * or -1 otherwise.
 * Reminding that word symbol 0 is for <epsilon> *)
function vosk_model_find_word(model: PVoskModel; const word_: PAnsiChar): Integer; cdecl;
  external LIB_VOSK name _PU + 'vosk_model_find_word';

(** Loads speaker model data from the file and returns the model object
 *
 * @param model_path: the path of the model on the filesystem
 * @returns model object or NULL if problem occured *)
function vosk_spk_model_new(const model_path: PAnsiChar): PVoskSpkModel; cdecl;
  external LIB_VOSK name _PU + 'vosk_spk_model_new';

(** Releases the model memory
 *
 *  The model object is reference-counted so if some recognizer
 *  depends on this model, model might still stay alive. When
 *  last recognizer is released, model will be released too. *)
procedure vosk_spk_model_free(model: PVoskSpkModel); cdecl;
  external LIB_VOSK name _PU + 'vosk_spk_model_free';

(** Creates the recognizer object
 *
 *  The recognizers process the speech and return text using shared model data
 *  @param model       VoskModel containing static data for recognizer. Model can be
 *                     shared across recognizers, even running in different threads.
 *  @param sample_rate The sample rate of the audio you going to feed into the recognizer.
 *                     Make sure this rate matches the audio content, it is a common
 *                     issue causing accuracy problems.
 *  @returns recognizer object or NULL if problem occured *)
function vosk_recognizer_new(model: PVoskModel; sample_rate: Single): PVoskRecognizer; cdecl;
  external LIB_VOSK name _PU + 'vosk_recognizer_new';

(** Creates the recognizer object with speaker recognition
 *
 *  With the speaker recognition mode the recognizer not just recognize
 *  text but also return speaker vectors one can use for speaker identification
 *
 *  @param model       VoskModel containing static data for recognizer. Model can be
 *                     shared across recognizers, even running in different threads.
 *  @param sample_rate The sample rate of the audio you going to feed into the recognizer.
 *                     Make sure this rate matches the audio content, it is a common
 *                     issue causing accuracy problems.
 *  @param spk_model speaker model for speaker identification
 *  @returns recognizer object or NULL if problem occured *)
function vosk_recognizer_new_spk(model: PVoskModel; sample_rate: Single; spk_model: PVoskSpkModel): PVoskRecognizer; cdecl;
  external LIB_VOSK name _PU + 'vosk_recognizer_new_spk';

(** Creates the recognizer object with the phrase list
 *
 *  Sometimes when you want to improve recognition accuracy and when you don't need
 *  to recognize large vocabulary you can specify a list of phrases to recognize. This
 *  will improve recognizer speed and accuracy but might return [unk] if user said
 *  something different.
 *
 *  Only recognizers with lookahead models support this type of quick configuration.
 *  Precompiled HCLG graph models are not supported.
 *
 *  @param model       VoskModel containing static data for recognizer. Model can be
 *                     shared across recognizers, even running in different threads.
 *  @param sample_rate The sample rate of the audio you going to feed into the recognizer.
 *                     Make sure this rate matches the audio content, it is a common
 *                     issue causing accuracy problems.
 *  @param grammar The string with the list of phrases to recognize as JSON array of strings,
 *                 for example "["one two three four five", "[unk]"]".
 *
 *  @returns recognizer object or NULL if problem occured *)
function vosk_recognizer_new_grm(model: PVoskModel; sample_rate: Single; const grammar: PAnsiChar): PVoskRecognizer; cdecl;
  external LIB_VOSK name _PU + 'vosk_recognizer_new_grm';

(** Adds speaker model to already initialized recognizer
 *
 * Can add speaker recognition model to already created recognizer. Helps to initialize
 * speaker recognition for grammar-based recognizer.
 *
 * @param spk_model Speaker recognition model *)
procedure vosk_recognizer_set_spk_model(recognizer: PVoskRecognizer; spk_model: PVoskSpkModel); cdecl;
  external LIB_VOSK name _PU + 'vosk_recognizer_set_spk_model';

(** Configures recognizer to output n-best results
 *
 * <pre>
 *   {
 *      "alternatives": [
 *          { "text": "one two three four five", "confidence": 0.97 },
 *          { "text": "one two three for five", "confidence": 0.03 },
 *      ]
 *   }
 * </pre>
 *
 * @param max_alternatives - maximum alternatives to return from recognition results
 *)
procedure vosk_recognizer_set_max_alternatives(recognizer: PVoskRecognizer; max_alternatives: Integer); cdecl;
  external LIB_VOSK name _PU + 'vosk_recognizer_set_max_alternatives';

(** Enables words with times in the output
 *
 * <pre>
 *   "result" : [{
 *       "conf" : 1.000000,
 *       "end" : 1.110000,
 *       "start" : 0.870000,
 *       "word" : "what"
 *     }, {
 *       "conf" : 1.000000,
 *       "end" : 1.530000,
 *       "start" : 1.110000,
 *       "word" : "zero"
 *     }, {
 *       "conf" : 1.000000,
 *       "end" : 1.950000,
 *       "start" : 1.530000,
 *       "word" : "zero"
 *     }, {
 *       "conf" : 1.000000,
 *       "end" : 2.340000,
 *       "start" : 1.950000,
 *       "word" : "zero"
 *     }, {
 *       "conf" : 1.000000,
 *       "end" : 2.610000,
 *       "start" : 2.340000,
 *       "word" : "one"
 *     }],
 * </pre>
 *
 * @param words - boolean value
 *)
procedure vosk_recognizer_set_words(recognizer: PVoskRecognizer; words: Integer); cdecl;
  external LIB_VOSK name _PU + 'vosk_recognizer_set_words';

(** Like above return words and confidences in partial results
 *
 * @param partial_words - boolean value
 *)
procedure vosk_recognizer_set_partial_words(recognizer: PVoskRecognizer; partial_words: Integer); cdecl;
  external LIB_VOSK name _PU + 'vosk_recognizer_set_partial_words';

(** Set NLSML output
 * @param nlsml - boolean value
 *)
procedure vosk_recognizer_set_nlsml(recognizer: PVoskRecognizer; nlsml: Integer); cdecl;
  external LIB_VOSK name _PU + 'vosk_recognizer_set_nlsml';

(** Accept voice data
 *
 *  accept and process new chunk of voice data
 *
 *  @param data - audio data in PCM 16-bit mono format
 *  @param length - length of the audio data
 *  @returns 1 if silence is occured and you can retrieve a new utterance with result method
 *           0 if decoding continues
 *           -1 if exception occured *)
function vosk_recognizer_accept_waveform(recognizer: PVoskRecognizer; const data: PAnsiChar; length: Integer): Integer; cdecl;
  external LIB_VOSK name _PU + 'vosk_recognizer_accept_waveform';

(** Same as above but the version with the short data for language bindings where you have
 *  audio as array of shorts *)
function vosk_recognizer_accept_waveform_s(recognizer: PVoskRecognizer; const data: PSmallint; length: Integer): Integer; cdecl;
  external LIB_VOSK name _PU + 'vosk_recognizer_accept_waveform_s';

(** Same as above but the version with the float data for language bindings where you have
 *  audio as array of floats *)
function vosk_recognizer_accept_waveform_f(recognizer: PVoskRecognizer; const data: PSingle; length: Integer): Integer; cdecl;
  external LIB_VOSK name _PU + 'vosk_recognizer_accept_waveform_f';

(** Returns speech recognition result
 *
 * @returns the result in JSON format which contains decoded line, decoded
 *          words, times in seconds and confidences. You can parse this result
 *          with any json parser
 *
 * <pre>
 *  {
 *    "text" : "what zero zero zero one"
 *  }
 * </pre>
 *
 * If alternatives enabled it returns result with alternatives, see also vosk_recognizer_set_alternatives().
 *
 * If word times enabled returns word time, see also vosk_recognizer_set_word_times().
 *)
function vosk_recognizer_result(recognizer: PVoskRecognizer): PAnsiChar; cdecl;
  external LIB_VOSK name _PU + 'vosk_recognizer_result';

(** Returns partial speech recognition
 *
 * @returns partial speech recognition text which is not yet finalized.
 *          result may change as recognizer process more data.
 *
 * <pre>
 * {
 *    "partial" : "cyril one eight zero"
 * }
 * </pre>
 *)
function vosk_recognizer_partial_result(recognizer: PVoskRecognizer): PAnsiChar; cdecl;
  external LIB_VOSK name _PU + 'vosk_recognizer_partial_result';

(** Returns speech recognition result. Same as result, but doesn't wait for silence
 *  You usually call it in the end of the stream to get final bits of audio. It
 *  flushes the feature pipeline, so all remaining audio chunks got processed.
 *
 *  @returns speech result in JSON format.
 *)
function vosk_recognizer_final_result(recognizer: PVoskRecognizer): PAnsiChar; cdecl;
  external LIB_VOSK name _PU + 'vosk_recognizer_final_result';

(** Resets the recognizer
 *
 *  Resets current results so the recognition can continue from scratch *)
procedure vosk_recognizer_reset(recognizer: PVoskRecognizer); cdecl;
  external LIB_VOSK name _PU + 'vosk_recognizer_reset';

(** Releases recognizer object
 *
 *  Underlying model is also unreferenced and if needed released *)
procedure vosk_recognizer_free(recognizer: PVoskRecognizer); cdecl;
  external LIB_VOSK name _PU + 'vosk_recognizer_free';

(** Set log level for Kaldi messages
 *
 *  @param log_level the level
 *     0 - default value to print info and error messages but no debug
 *     less than 0 - don't print info messages
 *     greather than 0 - more verbose mode
 *)
procedure vosk_set_log_level(log_level: Integer); cdecl;
  external LIB_VOSK name _PU + 'vosk_set_log_level';

(**
 *  Init, automatically select a CUDA device and allow multithreading.
 *  Must be called once from the main thread.
 *  Has no effect if HAVE_CUDA flag is not set.
 *)
procedure vosk_gpu_init(); cdecl;
  external LIB_VOSK name _PU + 'vosk_gpu_init';

(**
 *  Init CUDA device in a multi-threaded environment.
 *  Must be called for each thread.
 *  Has no effect if HAVE_CUDA flag is not set.
 *)
procedure vosk_gpu_thread_init(); cdecl;
  external LIB_VOSK name _PU + 'vosk_gpu_thread_init';

(** Creates the batch recognizer object
 *
 *  @returns model object or NULL if problem occured *)
function vosk_batch_model_new(): PVoskBatchModel; cdecl;
  external LIB_VOSK name _PU + 'vosk_batch_model_new';

(** Releases batch model object *)
procedure vosk_batch_model_free(model: PVoskBatchModel); cdecl;
  external LIB_VOSK name _PU + 'vosk_batch_model_free';

(** Wait for the processing *)
procedure vosk_batch_model_wait(model: PVoskBatchModel); cdecl;
  external LIB_VOSK name _PU + 'vosk_batch_model_wait';

(** Creates batch recognizer object
 *  @returns recognizer object or NULL if problem occured *)
function vosk_batch_recognizer_new(model: PVoskBatchModel; sample_rate: Single): PVoskBatchRecognizer; cdecl;
  external LIB_VOSK name _PU + 'vosk_batch_recognizer_new';

(** Releases batch recognizer object *)
procedure vosk_batch_recognizer_free(recognizer: PVoskBatchRecognizer); cdecl;
  external LIB_VOSK name _PU + 'vosk_batch_recognizer_free';

(** Accept batch voice data *)
procedure vosk_batch_recognizer_accept_waveform(recognizer: PVoskBatchRecognizer; const data: PAnsiChar; length: Integer); cdecl;
  external LIB_VOSK name _PU + 'vosk_batch_recognizer_accept_waveform';

(** Set NLSML output
 * @param nlsml - boolean value
 *)
procedure vosk_batch_recognizer_set_nlsml(recognizer: PVoskBatchRecognizer; nlsml: Integer); cdecl;
  external LIB_VOSK name _PU + 'vosk_batch_recognizer_set_nlsml';

(** Closes the stream *)
procedure vosk_batch_recognizer_finish_stream(recognizer: PVoskBatchRecognizer); cdecl;
  external LIB_VOSK name _PU + 'vosk_batch_recognizer_finish_stream';

(** Return results *)
function vosk_batch_recognizer_front_result(recognizer: PVoskBatchRecognizer): PAnsiChar; cdecl;
  external LIB_VOSK name _PU + 'vosk_batch_recognizer_front_result';

(** Release and free first retrieved result *)
procedure vosk_batch_recognizer_pop(recognizer: PVoskBatchRecognizer); cdecl;
  external LIB_VOSK name _PU + 'vosk_batch_recognizer_pop';

(** Get amount of pending chunks for more intelligent waiting *)
function vosk_batch_recognizer_get_pending_chunks(recognizer: PVoskBatchRecognizer): Integer; cdecl;
  external LIB_VOSK name _PU + 'vosk_batch_recognizer_get_pending_chunks';

implementation

end.
